'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
// **Github:** https://github.com/toajs/quic
//
// **License:** MIT
const error_1 = require("./error");
const common_1 = require("./common");
const frame_1 = require("./frame");
const protocol_1 = require("./protocol");
// --- QUIC Public Packet Header
//
//      0        1        2        3        4            8
// +--------+--------+--------+--------+--------+---    ---+
// | Public |    Connection ID (64)    ...                 | ->
// |Flags(8)|      (optional)                              |
// +--------+--------+--------+--------+--------+---    ---+
//
//      9       10       11        12
// +--------+--------+--------+--------+
// |      QUIC Version (32)            | ->
// |         (optional)                |
// +--------+--------+--------+--------+
//
//     13       14       15        16      17       18       19       20
// +--------+--------+--------+--------+--------+--------+--------+--------+
// |                        Diversification Nonce                          | ->
// |                              (optional)                               |
// +--------+--------+--------+--------+--------+--------+--------+--------+
//
//     21       22       23        24      25       26       27       28
// +--------+--------+--------+--------+--------+--------+--------+--------+
// |                   Diversification Nonce Continued                     | ->
// |                              (optional)                               |
// +--------+--------+--------+--------+--------+--------+--------+--------+
//
//     29       30       31        32      33       34       35       36
// +--------+--------+--------+--------+--------+--------+--------+--------+
// |                   Diversification Nonce Continued                     | ->
// |                              (optional)                               |
// +--------+--------+--------+--------+--------+--------+--------+--------+
//
//     37       38       39        40      41       42       43       44
// +--------+--------+--------+--------+--------+--------+--------+--------+
// |                   Diversification Nonce Continued                     | ->
// |                              (optional)                               |
// +--------+--------+--------+--------+--------+--------+--------+--------+
//
//     45      46       47        48       49       50
// +--------+--------+--------+--------+--------+--------+
// |           Packet Number (8, 16, 32, or 48)          |
// |                  (variable length)                  |
// +--------+--------+--------+--------+--------+--------+
// ---
//
// Public Flags:
// 0x01 = PUBLIC_FLAG_VERSION. Interpretation of this flag depends on whether the packet
//   is sent by the server or the client. When sent by the client, setting it indicates that
//   the header contains a QUIC Version (see below)...
// 0x02 = PUBLIC_FLAG_RESET. Set to indicate that the packet is a Public Reset packet.
// 0x04 = Indicates the presence of a 32 byte diversification nonce in the header.
// 0x08 = Indicates the full 8 byte Connection ID is present in the packet.
// Two bits at 0x30 indicate the number of low-order-bytes of the packet number that are present in each packet. The bits are only used for Frame Packets. For Public Reset and Version Negotiation Packets (sent by the server) which don't have a packet number, these bits are not used and must be set to 0. Within this 2 bit mask:
//   0x30 indicates that 6 bytes of the packet number is present
//   0x20 indicates that 4 bytes of the packet number is present
//   0x10 indicates that 2 bytes of the packet number is present
//   0x00 indicates that 1 byte of the packet number is present
// 0x40 is reserved for multipath use.
// 0x80 is currently unused, and must be set to 0.
function parsePacket(bufv, packetSentBy, _version) {
    bufv.v.walk(0); // align start and end
    let flag = bufv.readUIntLE(bufv.v.start, 1, true);
    // 0x80, currently unused
    if (flag >= 127)
        throw new error_1.QuicError('QUIC_INTERNAL_ERROR');
    // 0x08, connectionID
    if (!(flag & 0b1000))
        throw new error_1.QuicError('QUIC_INTERNAL_ERROR');
    if (flag & 0b10) {
        return ResetPacket.fromBuffer(bufv);
    }
    let hasVersion = flag & 0b1;
    if (hasVersion && packetSentBy === protocol_1.SessionType.SERVER) {
        return NegotiationPacket.fromBuffer(bufv);
    }
    return RegularPacket.fromBuffer(bufv, flag);
}
exports.parsePacket = parsePacket;
/** Packet representing a base Packet. */
class Packet {
    constructor(connectionID, flag) {
        this.flag = flag;
        this.connectionID = connectionID;
    }
    isReset() {
        return this instanceof ResetPacket;
    }
    isNegotiation() {
        return this instanceof NegotiationPacket;
    }
    isRegular() {
        return this instanceof RegularPacket;
    }
    static fromBuffer(_bufv, _flag) {
        throw new Error(`class method "fromBuffer" is not implemented`);
    }
}
exports.Packet = Packet;
/** ResetPacket representing a reset Packet. */
class ResetPacket extends Packet {
    constructor(connectionID, tags) {
        super(connectionID, 0b00001010);
        this.tags = tags;
        this.packetNumber = null;
        this.socketAddress = null;
        let nonceProof = tags.getTag('RNON');
        if (!nonceProof)
            throw new error_1.QuicError('QUIC_INVALID_PUBLIC_RST_PACKET');
        this.nonceProof = nonceProof;
        let rseq = tags.getTag('RSEQ');
        if (rseq) {
            this.packetNumber = protocol_1.PacketNumber.fromBuffer(common_1.Visitor.wrap(rseq), rseq.length);
        }
        let cadr = tags.getTag('CADR');
        if (cadr) {
            this.socketAddress = protocol_1.SocketAddress.fromBuffer(common_1.Visitor.wrap(cadr));
        }
    }
    byteLen() {
        return 9 + this.tags.byteLen();
    }
    writeTo(bufv) {
        bufv.v.walk(1);
        bufv.writeUInt8(this.flag, bufv.v.start, true);
        this.connectionID.writeTo(bufv);
        this.tags.writeTo(bufv);
        return bufv;
    }
    static fromBuffer(bufv) {
        bufv.v.walk(1); // flag
        let connectionID = protocol_1.ConnectionID.fromBuffer(bufv);
        let quicTag = protocol_1.QuicTag.fromBuffer(bufv);
        if (quicTag.name !== 'PRST' || quicTag.keys[0] !== 'RNON') {
            throw new error_1.QuicError('QUIC_INVALID_PUBLIC_RST_PACKET');
        }
        return new ResetPacket(connectionID, quicTag);
    }
}
exports.ResetPacket = ResetPacket;
/** NegotiationPacket representing a negotiation Packet. */
class NegotiationPacket extends Packet {
    constructor(connectionID, versions) {
        super(connectionID, 0b00001001);
        this.versions = versions;
    }
    byteLen() {
        return 9 + 4 * this.versions.length;
    }
    writeTo(bufv) {
        bufv.v.walk(1);
        bufv.writeUInt8(this.flag, bufv.v.start, true);
        this.connectionID.writeTo(bufv);
        for (let version of this.versions) {
            bufv.v.walk(4);
            bufv.write(version, bufv.v.start, 4);
        }
        return bufv;
    }
    static fromConnectionID(connectionID) {
        return new NegotiationPacket(connectionID, protocol_1.getVersions());
    }
    static fromBuffer(bufv) {
        bufv.v.walk(1); // flag
        let connectionID = protocol_1.ConnectionID.fromBuffer(bufv);
        let versions = [];
        while (bufv.length > bufv.v.end) {
            bufv.v.walk(4);
            let version = bufv.toString('utf8', bufv.v.start, bufv.v.end);
            if (!protocol_1.isSupportedVersion(version))
                throw new error_1.QuicError('QUIC_INVALID_VERSION');
            versions.push(version);
        }
        return new NegotiationPacket(connectionID, versions);
    }
}
exports.NegotiationPacket = NegotiationPacket;
/** RegularPacket representing a regular Packet. */
class RegularPacket extends Packet {
    constructor(connectionID, packetNumber, nonce = null) {
        let flag = 0b00001000;
        flag |= (packetNumber.flagBits() << 4);
        if (nonce)
            flag |= 0x04;
        super(connectionID, flag);
        this.packetNumber = packetNumber;
        this.version = ''; // 4 byte, string
        this.nonce = nonce; // 32 byte, buffer
        this.frames = [];
    }
    setVersion(version) {
        this.flag |= 0b00000001;
        this.version = version;
    }
    /**
     * @param {Array<Frame>} frames
     * @return {this}
     */
    addFrames(...frames) {
        this.frames.push(...frames);
        return this;
    }
    byteLen() {
        let len = 9;
        if (this.version) {
            len += 4;
        }
        if (this.nonce) {
            len += 32;
        }
        len += this.packetNumber.byteLen();
        for (let frame of this.frames) {
            len += frame.byteLen();
        }
        return len;
    }
    writeTo(bufv) {
        bufv.v.walk(1);
        bufv.writeUInt8(this.flag, bufv.v.start, true);
        this.connectionID.writeTo(bufv);
        if (this.version) {
            bufv.v.walk(4);
            bufv.write(this.version, bufv.v.start, 4);
        }
        if (this.nonce) {
            bufv.v.walk(32);
            this.nonce.copy(bufv, bufv.v.start, 0, 32);
        }
        this.packetNumber.writeTo(bufv);
        for (let frame of this.frames) {
            frame.writeTo(bufv);
        }
        return bufv;
    }
    static fromBuffer(bufv, flag) {
        bufv.v.walk(1); // flag
        let connectionID = protocol_1.ConnectionID.fromBuffer(bufv);
        let version = '';
        let hasVersion = flag & 0b1;
        if (hasVersion) {
            bufv.v.walk(4);
            version = bufv.toString('utf8', bufv.v.start, bufv.v.end);
            if (!protocol_1.isSupportedVersion(version))
                throw new error_1.QuicError('QUIC_INVALID_VERSION');
        }
        let nonce = null;
        if (flag & 0b100) {
            bufv.v.walk(32);
            nonce = bufv.slice(bufv.v.start, bufv.v.end);
            if (nonce.length !== 32)
                throw new error_1.QuicError('QUIC_INTERNAL_ERROR');
        }
        let packetNumber = protocol_1.PacketNumber.fromBuffer(bufv, protocol_1.PacketNumber.flagToByteLen((flag & 0b110000) >> 4));
        let packet = new RegularPacket(connectionID, packetNumber, nonce);
        if (version) {
            packet.setVersion(version);
        }
        while (bufv.v.end < bufv.length) {
            packet.addFrames(frame_1.parseFrame(bufv, packetNumber));
        }
        return packet;
    }
}
exports.RegularPacket = RegularPacket;
//# sourceMappingURL=packet.js.map