'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
// **Github:** https://github.com/toajs/quic
//
// **License:** MIT
const error_1 = require("./error");
const protocol_1 = require("./protocol");
const common_1 = require("./common");
// Frame Types
// | Type­field value | Control Frame­type |
//
// ----- Regular Frame Types
// | 00000000B (0x00) | PADDING |
// | 00000001B (0x01) | RST_STREAM |
// | 00000010B (0x02) | CONNECTION_CLOSE |
// | 00000011B (0x03) | GOAWAY |
// | 00000100B (0x04) | WINDOW_UPDATE |
// | 00000101B (0x05) | BLOCKED |
// | 00000110B (0x06) | STOP_WAITING |
// | 00000111B (0x07) | PING |
//
// ----- Special Frame Types
// | 001xxxxxB | CONGESTION_FEEDBACK |
// | 01ntllmmB | ACK |
// | 1fdooossB | STREAM |
// -----
function isCongestionType(flag) {
    return (flag & 0b11100000) === 0b00100000;
}
exports.isCongestionType = isCongestionType;
function isACKType(flag) {
    return (flag & 0b11000000) === 0b01000000;
}
exports.isACKType = isACKType;
function isStreamType(flag) {
    return flag > 0b10000000;
}
exports.isStreamType = isStreamType;
function parseFrame(bufv, headerPacketNumber) {
    bufv.v.walk(0); // align start and end
    let type = bufv.readUInt8(bufv.v.start, true);
    if (type >= 128)
        return StreamFrame.fromBuffer(bufv);
    if (type >= 64)
        return AckFrame.fromBuffer(bufv);
    if (type >= 32)
        return CongestionFeedbackFrame.fromBuffer(bufv);
    switch (type) {
        case 0:
            return PaddingFrame.fromBuffer(bufv);
        case 1:
            return RstStreamFrame.fromBuffer(bufv);
        case 2:
            return ConnectionCloseFrame.fromBuffer(bufv);
        case 3:
            return GoAwayFrame.fromBuffer(bufv);
        case 4:
            return WindowUpdateFrame.fromBuffer(bufv);
        case 5:
            return BlockedFrame.fromBuffer(bufv);
        case 6:
            return StopWaitingFrame.fromBuffer(bufv, headerPacketNumber);
        case 7:
            return PingFrame.fromBuffer(bufv);
        default:
            throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');
    }
}
exports.parseFrame = parseFrame;
/** Frame representing a QUIC frame. */
class Frame {
    constructor(type, name) {
        this.type = type;
        this.name = name;
    }
    static fromBuffer(_bufv, _headerPacketNumber) {
        throw new Error(`class method "fromBuffer" is not implemented`);
    }
}
exports.Frame = Frame;
/** StreamFrame representing a QUIC STREAM frame. */
class StreamFrame extends Frame {
    constructor(streamID, offset, data = null, isFIN = false) {
        super(0b10000000, 'STREAM');
        this.streamID = streamID;
        this.offset = offset;
        if (!isFIN && (!Buffer.isBuffer(data) || data.length === 0)) {
            throw new error_1.QuicError('QUIC_INVALID_STREAM_DATA');
        }
        this.data = data;
        this.isFIN = isFIN || data == null || data.length === 0;
    }
    byteLen() {
        let dataLen = this.data ? this.data.length : 0;
        return 1 + this.streamID.byteLen() + this.offset.byteLen() + (dataLen ? (dataLen + 2) : 0);
    }
    writeTo(bufv) {
        if (this.isFIN)
            this.type |= 0b1000000;
        if (this.data != null)
            this.type |= 0b00100000;
        this.type |= this.offset.flagBits() << 2;
        this.type |= this.streamID.flagBits();
        bufv.v.walk(1);
        bufv.writeUInt8(this.type, bufv.v.start);
        this.streamID.writeTo(bufv);
        this.offset.writeTo(bufv);
        if (this.data) {
            bufv.v.walk(2);
            bufv.writeUInt16LE(this.data.length, bufv.v.start, true);
            bufv.v.walk(this.data.length);
            this.data.copy(bufv, bufv.v.start, 0, this.data.length);
        }
        return bufv;
    }
    static fromBuffer(bufv) {
        bufv.v.walk(1);
        let type = bufv[bufv.v.start];
        if (!isStreamType(type))
            throw new error_1.QuicError('QUIC_INVALID_STREAM_DATA');
        let isFIN = !!(type & 0b1000000);
        let streamID = protocol_1.StreamID.fromBuffer(bufv, protocol_1.StreamID.flagToByteLen(type & 0b11));
        let offset = protocol_1.Offset.fromBuffer(bufv, protocol_1.Offset.flagToByteLen((type & 0b11100) >> 2));
        let data = null;
        if ((type & 0b100000) > 0) {
            bufv.v.walk(2);
            if (bufv.length < bufv.v.end)
                throw new error_1.QuicError('QUIC_INVALID_STREAM_DATA');
            bufv.v.walk(bufv.readUInt16LE(bufv.v.start, true));
            if (bufv.length < bufv.v.end)
                throw new error_1.QuicError('QUIC_INVALID_STREAM_DATA');
            data = bufv.slice(bufv.v.start, bufv.v.end);
        }
        let frame = new StreamFrame(streamID, offset, data, isFIN);
        frame.type = type;
        return frame;
    }
}
exports.StreamFrame = StreamFrame;
/** AckRange representing a range for ACK. */
class AckRange {
    constructor(firstPacketNumberValue, lastPacketNumberValue) {
        this.first = firstPacketNumberValue; // PacketNumber value
        this.last = lastPacketNumberValue;
    }
    len() {
        return this.last - this.first + 1;
    }
}
exports.AckRange = AckRange;
/** AckFrame representing a QUIC ACK frame. */
class AckFrame extends Frame {
    constructor() {
        super(0b01000000, 'ACK');
        this.largestAcked = 0; // largest PacketNumber Value
        this.lowestAcked = 0; // lowest PacketNumber Value
        // has to be ordered. The ACK range with the highest firstNum goes first, the ACK range with the lowest firstNum goes last
        this.ackRanges = [];
        this.delayTime = 0; // microseconds
        // time when the LargestAcked was received, this field Will not be set for received ACKs frames
        this.packetReceivedTime = null; // should be process.hrtime()
    }
    hasMissingRanges() {
        return this.ackRanges.length > 0;
    }
    validateAckRanges() {
        if (this.ackRanges.length === 0) {
            return true;
        }
        // if there are missing packets, there will always be at least 2 ACK ranges
        if (this.ackRanges.length === 1) {
            return false;
        }
        if (this.ackRanges[0].last !== this.largestAcked) {
            return false;
        }
        // check the validity of every single ACK range
        for (let ackRange of this.ackRanges) {
            if (ackRange.first > ackRange.last || ackRange.first <= 0) {
                return false;
            }
        }
        // check the consistency for ACK with multiple NACK ranges
        for (let i = 1, l = this.ackRanges.length; i < l; i++) {
            let lastAckRange = this.ackRanges[i - 1];
            if (lastAckRange.first <= this.ackRanges[i].first) {
                return false;
            }
            if (lastAckRange.first <= (this.ackRanges[i].last + 1)) {
                return false;
            }
        }
        return true;
    }
    numWritableNackRanges() {
        if (this.ackRanges.length === 0) {
            return 0;
        }
        let numRanges = 0;
        for (let i = 1, l = this.ackRanges.length; i < l; i++) {
            let lastAckRange = this.ackRanges[i - 1];
            let gap = lastAckRange.first - this.ackRanges[i].last - 1;
            let rangeLength = 1 + Math.floor(gap / 0xff);
            if (gap % 0xff === 0)
                rangeLength--;
            if (numRanges + rangeLength < 0xff)
                numRanges += rangeLength;
            else
                break;
        }
        return numRanges + 1;
    }
    getMissingNumberDeltaFlagBits() {
        let maxRangeLength = 0;
        if (this.hasMissingRanges()) {
            for (let ackRange of this.ackRanges) {
                let rangeLength = ackRange.len();
                if (rangeLength > maxRangeLength) {
                    maxRangeLength = rangeLength;
                }
            }
        }
        else {
            maxRangeLength = this.largestAcked - this.lowestAcked + 1;
        }
        if (maxRangeLength <= 0xff)
            return 0;
        if (maxRangeLength <= 0xffff)
            return 1;
        if (maxRangeLength <= 0xffffff)
            return 2;
        return 3;
    }
    acksPacket(val) {
        if (val < this.lowestAcked || val > this.largestAcked) {
            return false;
        }
        if (this.hasMissingRanges()) {
            // TODO: this could be implemented as a binary search
            for (let ackRange of this.ackRanges) {
                if (val >= ackRange.first && val <= ackRange.last) {
                    return true;
                }
            }
            return false;
        }
        // if packet doesn't have missing ranges
        return (val >= this.lowestAcked && val <= this.largestAcked);
    }
    byteLen() {
        let hasMissingRanges = this.hasMissingRanges();
        let largestAckedNum = new protocol_1.PacketNumber(this.largestAcked);
        let flagBits = this.getMissingNumberDeltaFlagBits();
        let largestAckedLen = largestAckedNum.byteLen();
        let missingNumberDeltaLen = protocol_1.PacketNumber.flagToByteLen(flagBits);
        let frameLen = 1 + largestAckedLen + 2;
        let numRanges = 0;
        // Blocks
        if (!hasMissingRanges)
            frameLen += missingNumberDeltaLen;
        else {
            numRanges = this.numWritableNackRanges();
            if (numRanges > 0xff)
                throw new Error('AckFrame: Too many ACK ranges');
            frameLen += missingNumberDeltaLen + 1;
            frameLen += (missingNumberDeltaLen + 1) * (numRanges - 1);
        }
        // Timestamps
        return frameLen + 1;
    }
    writeTo(bufv) {
        let hasMissingRanges = this.hasMissingRanges();
        if (hasMissingRanges)
            this.type |= 0b100000;
        let largestAckedNum = new protocol_1.PacketNumber(this.largestAcked);
        this.type |= largestAckedNum.flagBits() << 2;
        let flagBits = this.getMissingNumberDeltaFlagBits();
        this.type |= flagBits;
        let missingNumberDeltaLen = protocol_1.PacketNumber.flagToByteLen(flagBits);
        let numRanges = 0;
        bufv.v.walk(1);
        bufv.writeUInt8(this.type, bufv.v.start);
        largestAckedNum.writeTo(bufv);
        if (!this.delayTime && this.packetReceivedTime) {
            let delayTime = process.hrtime(this.packetReceivedTime); // [seconds, nanoseconds]
            this.delayTime = delayTime[0] * 1000 * 1000 + Math.floor(delayTime[1] / 1000); // microsecond
        }
        bufv.v.walk(2);
        common_1.writeUFloat16(bufv, this.delayTime, bufv.v.start);
        let numRangesWritten = 0;
        if (hasMissingRanges) {
            numRanges = this.numWritableNackRanges();
            if (numRanges > 0xff)
                throw new Error('AckFrame: Too many ACK ranges');
            bufv.v.walk(1);
            bufv.writeUInt8(numRanges - 1, bufv.v.start);
        }
        let firstAckBlockLength = 0;
        if (!hasMissingRanges) {
            firstAckBlockLength = this.largestAcked - this.lowestAcked + 1;
        }
        else {
            if (this.largestAcked !== this.ackRanges[0].last) {
                throw new Error('largestAcked does not match ACK ranges');
            }
            if (this.lowestAcked !== this.ackRanges[this.ackRanges.length - 1].first) {
                throw new Error('lowestAcked does not match ACK ranges');
            }
            firstAckBlockLength = this.largestAcked - this.ackRanges[0].first + 1;
            numRangesWritten++;
        }
        bufv.v.walk(missingNumberDeltaLen);
        bufv.writeUIntLE(firstAckBlockLength, bufv.v.start, missingNumberDeltaLen);
        for (let i = 1, l = this.ackRanges.length; i < l; i++) {
            let length = this.ackRanges[i].len();
            let gap = this.ackRanges[i - 1].first - this.ackRanges[i].last - 1;
            let num = Math.floor(gap / 0xff) + 1;
            if (gap % 0xff === 0) {
                num--;
            }
            if (num === 1) {
                bufv.v.walk(1);
                bufv.writeUInt8(gap, bufv.v.start);
                bufv.v.walk(missingNumberDeltaLen);
                bufv.writeUIntLE(length, bufv.v.start, missingNumberDeltaLen);
                numRangesWritten++;
            }
            else {
                for (let j = 0; j < num; j++) {
                    let lengthWritten = 0;
                    let gapWritten = 0;
                    if (j === num - 1) {
                        lengthWritten = length;
                        gapWritten = 1 + ((gap - 1) % 255);
                    }
                    else {
                        lengthWritten = 0;
                        gapWritten = 0xff;
                    }
                    bufv.v.walk(1);
                    bufv.writeUInt8(gapWritten, bufv.v.start);
                    bufv.v.walk(missingNumberDeltaLen);
                    bufv.writeUIntLE(lengthWritten, bufv.v.start, missingNumberDeltaLen);
                    numRangesWritten++;
                }
            }
            // this is needed if not all AckRanges can be written to the ACK frame (if there are more than 0xFF)
            if (numRangesWritten >= numRanges) {
                break;
            }
        }
        if (numRanges !== numRangesWritten) {
            throw new Error('BUG: Inconsistent number of ACK ranges written');
        }
        bufv.v.walk(1);
        bufv.writeUInt8(0, bufv.v.start); // no timestamps
        return bufv;
    }
    static fromBuffer(bufv) {
        bufv.v.walk(1);
        let type = bufv[bufv.v.start];
        if (!isACKType(type))
            throw new error_1.QuicError('QUIC_INVALID_ACK_DATA');
        let frame = new AckFrame();
        let hasMissingRanges = type & 0b00100000;
        let missingNumberDeltaLen = (2 * (type & 0b11)) || 1;
        frame.largestAcked = protocol_1.PacketNumber.fromBuffer(bufv, protocol_1.PacketNumber.flagToByteLen((type & 0b1100) >> 2)).valueOf();
        bufv.v.walk(2);
        if (bufv.length < bufv.v.end)
            throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');
        frame.delayTime = common_1.readUFloat16(bufv, bufv.v.start);
        let numAckBlocks = 0;
        if (hasMissingRanges) {
            bufv.v.walk(1);
            if (bufv.length < bufv.v.end)
                throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');
            numAckBlocks = bufv.readUInt8(bufv.v.start, true);
        }
        if (hasMissingRanges && numAckBlocks === 0) {
            throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');
        }
        bufv.v.walk(missingNumberDeltaLen);
        if (bufv.length < bufv.v.end)
            throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');
        let ackBlockLength = bufv.readUIntLE(bufv.v.start, missingNumberDeltaLen, true);
        let largestAcked = frame.largestAcked;
        if ((largestAcked > 0 && ackBlockLength < 1) || ackBlockLength > largestAcked) {
            throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');
        }
        if (hasMissingRanges) {
            let ackRange = new AckRange(largestAcked - ackBlockLength + 1, largestAcked);
            frame.ackRanges.push(ackRange);
            let inLongBlock = false;
            let lastRangeComplete = false;
            for (let i = 0; i < numAckBlocks; i++) {
                bufv.v.walk(1);
                if (bufv.length < bufv.v.end)
                    throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');
                let gap = bufv.readUInt8(bufv.v.start, true);
                bufv.v.walk(missingNumberDeltaLen);
                if (bufv.length < bufv.v.end)
                    throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');
                ackBlockLength = bufv.readUIntLE(bufv.v.start, missingNumberDeltaLen, true);
                if (inLongBlock) {
                    frame.ackRanges[frame.ackRanges.length - 1].first -= gap + ackBlockLength;
                    frame.ackRanges[frame.ackRanges.length - 1].last -= gap;
                }
                else {
                    lastRangeComplete = false;
                    ackRange = new AckRange(0, frame.ackRanges[frame.ackRanges.length - 1].first - gap - 1);
                    ackRange.first = ackRange.last - ackBlockLength + 1;
                    frame.ackRanges.push(ackRange);
                }
                if (ackBlockLength > 0) {
                    lastRangeComplete = true;
                }
                inLongBlock = (ackBlockLength === 0);
            }
            // if the last range was not complete, firstNum and lastNum make no sense
            // remove the range from frame.ackRanges
            if (!lastRangeComplete) {
                frame.ackRanges = frame.ackRanges.slice(0, -1);
            }
            frame.lowestAcked = frame.ackRanges[frame.ackRanges.length - 1].first;
        }
        else {
            if (frame.largestAcked === 0) {
                frame.lowestAcked = 0;
            }
            else {
                frame.lowestAcked = largestAcked - ackBlockLength + 1;
            }
        }
        if (!frame.validateAckRanges()) {
            throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');
        }
        bufv.v.walk(1);
        if (bufv.length < bufv.v.end)
            throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');
        let numTimestamp = bufv.readUInt8(bufv.v.start, true);
        if (numTimestamp > 0) {
            // Delta Largest acked
            bufv.v.walk(1);
            if (bufv.length < bufv.v.end)
                throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');
            // buf.readUInt8(v.start, true)
            // First Timestamp
            bufv.v.walk(4);
            if (bufv.length < bufv.v.end)
                throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');
            // buf.readUInt32LE(v.start, true)
            for (let i = 0; i < numTimestamp - 1; i++) {
                // Delta Largest acked
                bufv.v.walk(1);
                if (bufv.length < bufv.v.end)
                    throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');
                // buf.readUInt8(v.start, true)
                // Time Since Previous Timestamp
                bufv.v.walk(2);
                if (bufv.length < bufv.v.end)
                    throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');
                // buf.readUInt16LE(v.start, true)
            }
        }
        return frame;
    }
}
exports.AckFrame = AckFrame;
/** StopWaitingFrame representing a QUIC STOP_WAITING frame. */
class StopWaitingFrame extends Frame {
    constructor(packetNumber, leastUnacked) {
        super(0x06, 'STOP_WAITING');
        this.packetNumber = packetNumber; // packetNumber > leastUnacked
        this.leastUnacked = leastUnacked;
    }
    byteLen() {
        return 1 + this.packetNumber.byteLen();
    }
    writeTo(bufv) {
        let len = this.packetNumber.byteLen();
        bufv.v.walk(1);
        bufv.writeUInt8(this.type, bufv.v.start);
        bufv.v.walk(len);
        bufv.writeUIntLE(this.packetNumber.valueOf() - this.leastUnacked.valueOf(), bufv.v.start, len);
        return bufv;
    }
    static fromBuffer(bufv, packetNumber) {
        bufv.v.walk(1);
        let type = bufv[bufv.v.start];
        if (type !== 0x06)
            throw new error_1.QuicError('QUIC_INVALID_STOP_WAITING_DATA');
        let len = packetNumber.byteLen();
        bufv.v.walk(len);
        if (bufv.length < bufv.v.end)
            throw new error_1.QuicError('QUIC_INVALID_STOP_WAITING_DATA');
        let delta = bufv.readIntLE(bufv.v.start, len, false);
        return new StopWaitingFrame(packetNumber, new protocol_1.PacketNumber(packetNumber.valueOf() - delta));
    }
}
exports.StopWaitingFrame = StopWaitingFrame;
/** WindowUpdateFrame representing a QUIC WINDOW_UPDATE frame. */
class WindowUpdateFrame extends Frame {
    constructor(streamID, offset) {
        super(0x04, 'WINDOW_UPDATE');
        this.streamID = streamID;
        this.offset = offset;
    }
    byteLen() {
        return 13;
    }
    writeTo(bufv) {
        bufv.v.walk(1);
        bufv.writeUInt8(this.type, bufv.v.start);
        this.streamID.writeTo(bufv, true);
        this.offset.writeTo(bufv, true);
        return bufv;
    }
    static fromBuffer(bufv) {
        bufv.v.walk(1);
        let type = bufv[bufv.v.start];
        if (type !== 0x04)
            throw new error_1.QuicError('QUIC_INVALID_WINDOW_UPDATE_DATA');
        let streamID = protocol_1.StreamID.fromBuffer(bufv, 4);
        let offset = protocol_1.Offset.fromBuffer(bufv, 8);
        return new WindowUpdateFrame(streamID, offset);
    }
}
exports.WindowUpdateFrame = WindowUpdateFrame;
/** BlockedFrame representing a QUIC BLOCKED frame. */
class BlockedFrame extends Frame {
    constructor(streamID) {
        super(0x05, 'BLOCKED');
        this.streamID = streamID;
    }
    byteLen() {
        return 5;
    }
    writeTo(bufv) {
        bufv.v.walk(1);
        bufv.writeUInt8(this.type, bufv.v.start);
        this.streamID.writeTo(bufv, true);
        return bufv;
    }
    static fromBuffer(bufv) {
        bufv.v.walk(1);
        let type = bufv[bufv.v.start];
        if (type !== 0x05)
            throw new error_1.QuicError('QUIC_INVALID_BLOCKED_DATA');
        let streamID = protocol_1.StreamID.fromBuffer(bufv, 4);
        return new BlockedFrame(streamID);
    }
}
exports.BlockedFrame = BlockedFrame;
/** CongestionFeedbackFrame representing a QUIC CONGESTION_FEEDBACK frame. */
class CongestionFeedbackFrame extends Frame {
    // CONGESTION_FEEDBACK Frame
    // The CONGESTION_FEEDBACK frame is an experimental frame currently not used.
    // It is intended to provide extra congestion feedback information outside the scope of
    // the standard ack frame. A CONGESTION_FEEDBACK frame must have the first three bits of
    // the Frame Type set to 001. The last 5 bits of the Frame Type field are reserved for future use.
    constructor() {
        super(0b00100000, 'CONGESTION_FEEDBACK');
    }
    byteLen() {
        return 1;
    }
    writeTo(bufv) {
        bufv.v.walk(1);
        bufv.writeUInt8(this.type, bufv.v.start);
        return bufv;
    }
    static fromBuffer(bufv) {
        bufv.v.walk(1);
        let type = bufv[bufv.v.start];
        if (!isCongestionType(type))
            throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');
        return new CongestionFeedbackFrame();
    }
}
exports.CongestionFeedbackFrame = CongestionFeedbackFrame;
/** PaddingFrame representing a QUIC PADDING frame. */
class PaddingFrame extends Frame {
    // PADDING Frame
    // The PADDING frame pads a packet with 0x00 bytes. When this frame is encountered,
    // the rest of the packet is expected to be padding bytes. The frame contains 0x00 bytes
    // and extends to the end of the QUIC packet. A PADDING frame only has a Frame Type field,
    // and must have the 8-bit Frame Type field set to 0x00.
    constructor() {
        super(0x00, 'PADDING');
    }
    byteLen() {
        return 1;
    }
    writeTo(bufv) {
        bufv.v.walk(1);
        bufv.writeUInt8(0, bufv.v.start);
        return bufv;
    }
    static fromBuffer(bufv) {
        bufv.v.walk(1);
        let type = bufv[bufv.v.start];
        if (type)
            throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');
        return new PaddingFrame();
    }
}
exports.PaddingFrame = PaddingFrame;
/** RstStreamFrame representing a QUIC RST_STREAM frame. */
class RstStreamFrame extends Frame {
    constructor(streamID, offset, error) {
        super(0x01, 'RST_STREAM');
        this.streamID = streamID;
        this.offset = offset;
        this.error = error;
    }
    byteLen() {
        return 17;
    }
    writeTo(bufv) {
        bufv.v.walk(1);
        bufv.writeUInt8(this.type, bufv.v.start);
        this.streamID.writeTo(bufv, true);
        this.offset.writeTo(bufv, true);
        this.error.writeTo(bufv);
        return bufv;
    }
    static fromBuffer(bufv) {
        bufv.v.walk(1);
        let type = bufv[bufv.v.start];
        if (type !== 0x01 || bufv.length < (bufv.v.end + 16))
            throw new error_1.QuicError('QUIC_INVALID_RST_STREAM_DATA');
        let streamID = protocol_1.StreamID.fromBuffer(bufv, 4);
        let offset = protocol_1.Offset.fromBuffer(bufv, 8);
        let error = error_1.QuicError.fromBuffer(bufv);
        return new RstStreamFrame(streamID, offset, error);
    }
}
exports.RstStreamFrame = RstStreamFrame;
/** PingFrame representing a QUIC PING frame. */
class PingFrame extends Frame {
    // PING frame
    // The PING frame can be used by an endpoint to verify that
    // a peer is still alive. The PING frame contains no payload.
    // The receiver of a PING frame simply needs to ACK the packet containing this frame.
    // The PING frame should be used to keep a connection alive when a stream is open.
    // The default is to do this after 15 seconds of quiescence,
    // which is much shorter than most NATs time out. A PING frame only
    // has a Frame Type field, and must have the 8-bit Frame Type field set to 0x07.
    constructor() {
        super(0x07, 'PING');
    }
    byteLen() {
        return 1;
    }
    writeTo(bufv) {
        bufv.v.walk(1);
        bufv.writeUInt8(this.type, bufv.v.start);
        return bufv;
    }
    static fromBuffer(bufv) {
        bufv.v.walk(1);
        let type = bufv[bufv.v.start];
        if (type !== 0x07)
            throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');
        return new PingFrame();
    }
}
exports.PingFrame = PingFrame;
/** ConnectionCloseFrame representing a QUIC CONNECTION_CLOSE frame. */
class ConnectionCloseFrame extends Frame {
    constructor(error) {
        super(0x02, 'CONNECTION_CLOSE');
        this.error = error;
    }
    byteLen() {
        let reasonPhrase = this.error.message;
        let reasonPhraseLen = reasonPhrase ? Buffer.byteLength(reasonPhrase) : 0;
        return 7 + reasonPhraseLen;
    }
    writeTo(bufv) {
        let reasonPhrase = this.error.message;
        let reasonPhraseLen = reasonPhrase ? Buffer.byteLength(reasonPhrase) : 0;
        bufv.v.walk(1);
        bufv.writeUInt8(this.type, bufv.v.start);
        this.error.writeTo(bufv);
        bufv.v.walk(2);
        bufv.writeUInt16LE(reasonPhraseLen, bufv.v.start, true);
        if (reasonPhrase) {
            bufv.v.walk(reasonPhraseLen);
            bufv.write(reasonPhrase, bufv.v.start, reasonPhraseLen);
        }
        return bufv;
    }
    static fromBuffer(bufv) {
        bufv.v.walk(1);
        let type = bufv[bufv.v.start];
        if (type !== 0x02 || bufv.length < (bufv.v.end + 6))
            throw new error_1.QuicError('QUIC_INVALID_CONNECTION_CLOSE_DATA');
        let error = error_1.QuicError.fromBuffer(bufv);
        bufv.v.walk(2);
        let reasonPhraseLen = bufv.readUInt16LE(bufv.v.start, true);
        if (reasonPhraseLen) {
            bufv.v.walk(reasonPhraseLen);
            if (bufv.length < bufv.v.end)
                throw new error_1.QuicError('QUIC_INVALID_CONNECTION_CLOSE_DATA');
            error.message = bufv.toString('utf8', bufv.v.start, bufv.v.end);
        }
        return new ConnectionCloseFrame(error);
    }
}
exports.ConnectionCloseFrame = ConnectionCloseFrame;
/** GoAwayFrame representing a QUIC GOAWAY frame. */
class GoAwayFrame extends Frame {
    constructor(lastGoodStreamID, error) {
        super(0x03, 'GOAWAY');
        this.streamID = lastGoodStreamID;
        this.error = error;
    }
    byteLen() {
        let reasonPhrase = this.error.message;
        let reasonPhraseLen = reasonPhrase ? Buffer.byteLength(reasonPhrase) : 0;
        return 11 + reasonPhraseLen;
    }
    writeTo(bufv) {
        let reasonPhrase = this.error.message;
        let reasonPhraseLen = reasonPhrase ? Buffer.byteLength(reasonPhrase) : 0;
        bufv.v.walk(1);
        bufv.writeUInt8(this.type, bufv.v.start);
        this.error.writeTo(bufv);
        this.streamID.writeTo(bufv, true);
        bufv.v.walk(2);
        bufv.writeUInt16LE(reasonPhraseLen, bufv.v.start, true);
        if (reasonPhrase) {
            bufv.v.walk(reasonPhraseLen);
            bufv.write(reasonPhrase, bufv.v.start, reasonPhraseLen);
        }
        return bufv;
    }
    static fromBuffer(bufv) {
        bufv.v.walk(1);
        let type = bufv[bufv.v.start];
        if (type !== 0x03)
            throw new error_1.QuicError('QUIC_INVALID_GOAWAY_DATA');
        let error = error_1.QuicError.fromBuffer(bufv);
        let streamID = protocol_1.StreamID.fromBuffer(bufv, 4);
        bufv.v.walk(2);
        if (bufv.length < bufv.v.end)
            throw new error_1.QuicError('QUIC_INVALID_GOAWAY_DATA');
        let reasonPhraseLen = bufv.readUInt16LE(bufv.v.start, true);
        if (reasonPhraseLen) {
            bufv.v.walk(reasonPhraseLen);
            if (bufv.length < bufv.v.end)
                throw new error_1.QuicError('QUIC_INVALID_GOAWAY_DATA');
            error.message = bufv.toString('utf8', bufv.v.start, bufv.v.end);
        }
        return new GoAwayFrame(streamID, error);
    }
}
exports.GoAwayFrame = GoAwayFrame;
//# sourceMappingURL=frame.js.map