'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
// **Github:** https://github.com/toajs/quic
//
// **License:** MIT
const dgram_1 = require("dgram");
const common_1 = require("./internal/common");
const packet_1 = require("./internal/packet");
const error_1 = require("./internal/error");
const protocol_1 = require("./internal/protocol");
const symbol_1 = require("./internal/symbol");
const session_1 = require("./session");
const util_1 = require("util");
const debug = util_1.debuglog('quic');
//
// *************** Client ***************
//
class Client extends session_1.Session {
    constructor() {
        super(protocol_1.ConnectionID.random(), protocol_1.SessionType.CLIENT);
        this[symbol_1.kVersion] = protocol_1.getVersion();
        this[symbol_1.kClientState] = new ClientState();
    }
    async connect(port, address) {
        if (this[symbol_1.kSocket])
            throw new Error('Client connecting duplicated');
        let addr = await common_1.lookup(address || 'localhost');
        debug(`client connect: ${address || 'localhost'}, ${port}`, addr);
        this[symbol_1.kState].remotePort = port;
        this[symbol_1.kState].remoteAddress = addr.address;
        this[symbol_1.kState].remoteFamily = 'IPv' + addr.family;
        this[symbol_1.kState].remoteAddr = new protocol_1.SocketAddress({ port: port, address: addr.address, family: `IPv${addr.family}` });
        const socket = this[symbol_1.kSocket] = dgram_1.createSocket(addr.family === 4 ? 'udp4' : 'udp6');
        socket
            .on('error', (err) => this.emit('error', err))
            .on('close', () => clientOnClose(this))
            .on('message', (msg, rinfo) => clientOnMessage(this, msg, rinfo));
        let res = new Promise((resolve, reject) => {
            socket.once('listening', () => {
                socket.removeListener('error', reject);
                let addr = socket.address();
                this[symbol_1.kState].localFamily = addr.family;
                this[symbol_1.kState].localAddress = addr.address;
                this[symbol_1.kState].localPort = addr.port;
                this[symbol_1.kState].localAddr = new protocol_1.SocketAddress(addr);
                resolve();
                this.emit('connect');
            });
            socket.once('error', reject);
        });
        socket.bind({ exclusive: true, port: 0 });
        return res;
    }
}
exports.Client = Client;
class ClientState {
    constructor() {
        this.receivedNegotiationPacket = false;
    }
}
exports.ClientState = ClientState;
function clientOnMessage(client, msg, rinfo) {
    debug(`client message: session ${client.id}, ${msg.length} bytes`, rinfo);
    if (!msg.length) {
        return;
    }
    // The packet size should not exceed protocol.MaxReceivePacketSize bytes
    // If it does, we only read a truncated packet, which will then end up undecryptable
    if (msg.length > protocol_1.MaxReceivePacketSize) {
        debug(`receive too large data: ${msg.length} bytes`);
        msg = msg.slice(0, protocol_1.MaxReceivePacketSize);
    }
    let senderAddr = new protocol_1.SocketAddress(rinfo);
    let rcvTime = Date.now();
    let bufv = common_1.Visitor.wrap(msg);
    let packet = null;
    try {
        packet = packet_1.parsePacket(bufv, protocol_1.SessionType.SERVER, client[symbol_1.kVersion]);
    }
    catch (err) {
        debug(`session ${client.id}: parsing packet error: ${err.message}`, JSON.stringify(rinfo));
        // drop this packet if we can't parse the Public Header
        return;
    }
    // reject packets with the wrong connection ID
    if (!client[symbol_1.kID].equals(packet.connectionID)) {
        debug(`received a spoofed packet with wrong connection ID. Ignoring.`);
        return;
    }
    if (packet.isReset()) {
        // check if the remote address and the connection ID match
        // otherwise this might be an attacker trying to inject a PUBLIC_RESET to kill the connection
        let remoteAddr = client[symbol_1.kState].remoteAddr;
        if (!remoteAddr || !remoteAddr.equals(senderAddr)) {
            debug(`received a spoofed Public Reset. Ignoring.`);
            return;
        }
        let packetNumber = packet.packetNumber;
        client._closeRemote(new Error(`Received Public Reset, rejected packet number: ${packetNumber}.`));
        return;
    }
    if (packet.isNegotiation()) {
        // ignore delayed / duplicated version negotiation packets
        if (client[symbol_1.kClientState].receivedNegotiationPacket || client[symbol_1.kState].versionNegotiated) {
            return;
        }
        let versions = packet.versions;
        if (client[symbol_1.kVersion] && versions.includes(client[symbol_1.kVersion])) {
            // the version negotiation packet contains the version that we offered
            // this might be a packet sent by an attacker (or by a terribly broken server implementation)
            // ignore it
            return;
        }
        let newVersion = protocol_1.chooseVersion(versions);
        client[symbol_1.kClientState].receivedNegotiationPacket = true;
        if (newVersion) {
            // switch to negotiated version
            client[symbol_1.kVersion] = newVersion;
            // TODO: resend all packets using this version
        }
        else {
            client.close(new error_1.QuicError('QUIC_INVALID_VERSION'));
        }
        return;
    }
    // this is the first packet after the client sent a packet with the VersionFlag set
    // if the server doesn't send a version negotiation packet, it supports the suggested version
    if (!client[symbol_1.kState].versionNegotiated) {
        client[symbol_1.kState].versionNegotiated = true;
        client.emit('version', client.version);
    }
    client[symbol_1.kState].bytesRead += msg.length;
    client._handleRegularPacket(packet, rcvTime, bufv);
}
function clientOnClose(_session) {
}
//# sourceMappingURL=client.js.map