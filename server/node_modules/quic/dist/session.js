'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
// **Github:** https://github.com/toajs/quic
//
// **License:** MIT
const events_1 = require("events");
const protocol_1 = require("./internal/protocol");
const symbol_1 = require("./internal/symbol");
const frame_1 = require("./internal/frame");
const packet_1 = require("./internal/packet");
const stream_1 = require("./stream");
const common_1 = require("./internal/common");
//
// *************** Session ***************
//
class Session extends events_1.EventEmitter {
    constructor(id, type) {
        super();
        this[symbol_1.kID] = id;
        this[symbol_1.kType] = type;
        this[symbol_1.kStreams] = new Map();
        this[symbol_1.kNextStreamID] = new protocol_1.StreamID(type === protocol_1.SessionType.SERVER ? 2 : 1);
        this[symbol_1.kState] = new SessionState();
        this[symbol_1.kACKHandler] = new ACKHandler();
        this[symbol_1.kSocket] = null;
        this[symbol_1.kVersion] = '';
        this[symbol_1.kNextPacketNumber] = new protocol_1.PacketNumber(1);
        this.setMaxListeners((2 ** 31) - 1);
    }
    get id() {
        return this[symbol_1.kID].valueOf();
    }
    get version() {
        return this[symbol_1.kVersion];
    }
    get isClient() {
        return this[symbol_1.kType] === protocol_1.SessionType.CLIENT;
    }
    get destroyed() {
        return this[symbol_1.kState].destroyed;
    }
    get localAddr() {
        return {
            port: this[symbol_1.kState].localPort,
            family: this[symbol_1.kState].localFamily,
            address: this[symbol_1.kState].localAddress,
            socketAddress: this[symbol_1.kState].localAddr
        };
    }
    get remoteAddr() {
        return {
            port: this[symbol_1.kState].remotePort,
            family: this[symbol_1.kState].remoteFamily,
            address: this[symbol_1.kState].remoteAddress,
            socketAddress: this[symbol_1.kState].remoteAddr
        };
    }
    _sendFrame(frame, callback) {
        let packetNumber = this[symbol_1.kNextPacketNumber];
        this[symbol_1.kNextPacketNumber] = packetNumber.nextNumber();
        let regularPacket = new packet_1.RegularPacket(this[symbol_1.kID], packetNumber);
        regularPacket.addFrames(frame);
        this._sendPacket(regularPacket, callback);
    }
    // _onPacket (packet) {}
    _sendPacket(packet, callback) {
        if (this.isClient && !this[symbol_1.kState].versionNegotiated && packet.isRegular()) {
            packet.setVersion(this[symbol_1.kVersion]);
        }
        let buf = common_1.toBuffer(packet);
        let socket = this[symbol_1.kSocket];
        if (!socket)
            return callback(new Error('UDP not connect'));
        socket.send(buf, this[symbol_1.kState].remotePort, this[symbol_1.kState].remoteAddress, callback);
    }
    _handleRegularPacket(packet, rcvTime, _bufv) {
        if (this.isClient && packet.nonce) {
            // TODO
            // this.cryptoSetup.SetDiversificationNonce(packet.nonce)
        }
        this[symbol_1.kState].lastNetworkActivityTime = rcvTime;
        this[symbol_1.kState].keepAlivePingSent = false;
        for (let frame of packet.frames) {
            switch (frame.name) {
                case 'STREAM':
                    this._handleStreamFrame(frame);
                    break;
                case 'ACK':
                    this._handleACKFrame(frame);
                    break;
                case 'STOP_WAITING':
                    break;
                case 'WINDOW_UPDATE':
                    break;
                case 'BLOCKED':
                    break;
                case 'CONGESTION_FEEDBACK':
                    break;
                case 'PADDING':
                    break;
                case 'RST_STREAM':
                    break;
                case 'PING':
                    this.emit('ping');
                    break;
                case 'CONNECTION_CLOSE':
                    this._closeLocal(frame.error);
                    break;
                case 'GOAWAY':
                    break;
            }
        }
    }
    /**
     * @param {StreamFrame} frame
     */
    _handleStreamFrame(frame) {
        let streamID = frame.streamID.valueOf();
        let stream = this[symbol_1.kStreams].get(streamID);
        if (!stream) {
            stream = new stream_1.Stream(frame.streamID, this, {});
            this[symbol_1.kStreams].set(streamID, stream);
            this.emit('stream', stream);
        }
        // TODO: ACK and reorder by offset
        stream._handleFrame(frame);
    }
    _handleACKFrame(_frame) {
        this[symbol_1.kACKHandler].ack(_frame);
    }
    request(options) {
        let streamID = this[symbol_1.kNextStreamID];
        this[symbol_1.kNextStreamID] = streamID.nextID();
        let stream = new stream_1.Stream(streamID, this, options || {});
        this[symbol_1.kStreams].set(streamID.valueOf(), stream);
        return stream;
    }
    goaway(_code, _lastStreamID, _opaqueData) { }
    ping() {
        return new Promise((resolve, reject) => {
            this._sendFrame(new frame_1.PingFrame(), (err) => {
                if (err != null)
                    reject(err);
                else
                    resolve();
            });
        });
    }
    setTimeout(_msecs) { }
    // Graceful or immediate shutdown of the Session. Graceful shutdown
    // is only supported on the server-side
    close(_err) { }
    _closeRemote(_err) { }
    _closeLocal(_err) { }
    destroy() { }
    ref() { }
    unref() { }
}
exports.Session = Session;
class SessionState {
    constructor() {
        this.localFamily = '';
        this.localAddress = '';
        this.localPort = 0;
        this.localAddr = null; // SocketAddress
        this.remoteFamily = '';
        this.remoteAddress = '';
        this.remotePort = 0;
        this.remoteAddr = null; // SocketAddress
        this.pendingAck = 0;
        this.bytesRead = 0;
        this.bytesWritten = 0;
        this.lastNetworkActivityTime = 0;
        this.destroyed = false;
        this.shutdown = false;
        this.shuttingDown = false;
        this.versionNegotiated = false;
        this.keepAlivePingSent = false;
    }
}
exports.SessionState = SessionState;
class ACKHandler {
    ack(_val) { }
}
exports.ACKHandler = ACKHandler;
//# sourceMappingURL=session.js.map