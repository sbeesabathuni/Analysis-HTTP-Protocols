'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
// **Github:** https://github.com/toajs/quic
//
// **License:** MIT
const stream_1 = require("stream");
const error_1 = require("./internal/error");
const protocol_1 = require("./internal/protocol");
const frame_1 = require("./internal/frame");
const symbol_1 = require("./internal/symbol");
class Stream extends stream_1.Duplex {
    constructor(streamID, session, options) {
        options.allowHalfOpen = true;
        options.decodeStrings = false;
        options.objectMode = false;
        super(options);
        // this.cork()
        this[symbol_1.kID] = streamID;
        this[symbol_1.kSession] = session;
        this[symbol_1.kState] = new StreamState();
    }
    // The socket owned by this session
    get id() {
        return this[symbol_1.kID].valueOf();
    }
    get session() {
        return this[symbol_1.kSession];
    }
    get aborted() {
        return this[symbol_1.kState].aborted;
    }
    // get closed (): boolean {
    // }
    // get destroyed (): boolean {}
    close(_code) { }
    // Reset closes the stream with an error.
    reset(err) {
        this[symbol_1.kState].localFIN = true;
        let offset = this[symbol_1.kState].writeOffset;
        let rstStreamFrame = new frame_1.RstStreamFrame(this[symbol_1.kID], offset, error_1.QuicStreamError.fromError(err));
        return new Promise((resolve, reject) => {
            this[symbol_1.kSession]._sendFrame(rstStreamFrame, (err) => {
                if (err != null)
                    reject(err);
                else
                    resolve(offset.valueOf());
            });
        });
    }
    _handleFrame(frame) {
        if (frame.data != null) {
            this[symbol_1.kState].bytesRead += frame.data.length;
            this[symbol_1.kState].readQueue.push(frame);
        }
        if (frame.isFIN && !this[symbol_1.kState].remoteFIN) {
            this[symbol_1.kState].remoteFIN = true;
            this[symbol_1.kState].readQueue.setEndOffset(frame.offset.valueOf());
        }
        this._read(protocol_1.MaxStreamBufferSize * 10); // try to read all
    }
    _flushData(shouldFin, callback) {
        let buf = this[symbol_1.kState].bufferList.read(protocol_1.MaxStreamBufferSize);
        if (buf == null && !shouldFin)
            return callback();
        let offet = this[symbol_1.kState].writeOffset;
        if (buf != null) {
            this[symbol_1.kState].writeOffset = offet.nextOffset(buf.length);
        }
        let streamFrame = new frame_1.StreamFrame(this[symbol_1.kID], offet, buf, (shouldFin && this[symbol_1.kState].bufferList.length === 0));
        if (streamFrame.isFIN)
            this[symbol_1.kState].localFIN = true;
        this[symbol_1.kSession]._sendFrame(streamFrame, (err) => {
            if (err != null)
                return callback(err);
            if (this[symbol_1.kState].bufferList.length === 0)
                return callback();
            this._flushData(shouldFin, callback);
        });
    }
    _write(chunk, _encoding, callback) {
        if (this[symbol_1.kState].localFIN)
            return callback(new error_1.QuicStreamError('QUIC_RST_ACKNOWLEDGEMENT'));
        if (!(chunk instanceof Buffer))
            return callback(new Error('invalid data'));
        this[symbol_1.kState].bufferList.push(chunk);
        this._flushData(false, callback);
    }
    _final(callback) {
        this._flushData(true, callback);
    }
    _read(size = 0) {
        let data = this[symbol_1.kState].readQueue.read();
        if (data != null) {
            if (this.push(data) && size > data.length) {
                this._read(size - data.length);
                return;
            }
        }
        if (!this[symbol_1.kState].ended && this[symbol_1.kState].readQueue.isEnd()) {
            this[symbol_1.kState].ended = true;
            this.push(null);
        }
    }
}
exports.Stream = Stream;
class StreamState {
    constructor() {
        this.localFIN = false; // local endpoint will not send data
        this.remoteFIN = false; // remote endpoint should not send data
        this.ended = false;
        this.aborted = false;
        this.finished = false;
        this.bytesRead = 0;
        this.bytesWritten = 0;
        this.readQueue = new StreamFramesSorter();
        this.bufferList = new StreamDataList();
        this.writeOffset = new protocol_1.Offset(0);
    }
}
class StreamDataEntry {
    constructor(buf, entry) {
        this.data = buf;
        this.next = entry;
    }
}
class StreamDataList {
    constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    push(buf) {
        let entry = new StreamDataEntry(buf, null);
        if (this.tail) {
            this.tail.next = entry;
        }
        else {
            this.head = entry;
        }
        this.tail = entry;
        this.length += 1;
    }
    shift() {
        if (!this.head)
            return null;
        let ret = this.head.data;
        if (this.length === 1) {
            this.head = this.tail = null;
        }
        else {
            this.head = this.head.next;
        }
        this.length -= 1;
        return ret;
    }
    read(n) {
        if (!this.head)
            return null;
        let ret = this.head.data;
        if (ret.length > n) {
            this.head.data = ret.slice(n);
            ret = ret.slice(0, n);
            return ret;
        }
        this.shift();
        return ret; // ret.length <= n
    }
}
class StreamFrameEntry {
    constructor(frame, entry) {
        this.data = frame.data;
        this.offset = frame.offset.valueOf();
        this.next = entry;
    }
}
class StreamFramesSorter {
    constructor() {
        this.head = null;
        this.readOffset = 0;
        this.endOffset = -1;
    }
    setEndOffset(offset) {
        this.endOffset = offset;
    }
    isEnd() {
        return this.readOffset === this.endOffset;
    }
    /**
     * @param {StreamFrame}
     */
    push(frame) {
        let entry = new StreamFrameEntry(frame, null);
        let offset = entry.offset;
        if (this.head == null) {
            this.head = entry;
        }
        else if (this.head.offset > offset) {
            entry.next = this.head;
            this.head = entry;
        }
        else {
            let prev = this.head;
            while (true) {
                if (prev.next == null) {
                    prev.next = entry;
                    break;
                }
                if (prev.next.offset > offset) {
                    entry.next = prev.next;
                    prev.next = entry;
                    break;
                }
                prev = prev.next;
            }
        }
    }
    read() {
        let data = null;
        if (this.head != null && this.readOffset === this.head.offset) {
            data = this.head.data;
            this.readOffset = this.head.offset + (data ? data.length : 0);
            this.head = this.head.next;
        }
        return data;
    }
}
//# sourceMappingURL=stream.js.map