'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
// **Github:** https://github.com/toajs/quic
//
// **License:** MIT
const util_1 = require("util");
const events_1 = require("events");
const dgram_1 = require("dgram");
const common_1 = require("./internal/common");
const packet_1 = require("./internal/packet");
// import { QuicError } from './internal/error'
const symbol_1 = require("./internal/symbol");
const protocol_1 = require("./internal/protocol");
const session_1 = require("./session");
const debug = util_1.debuglog('quic');
class ServerSession extends session_1.Session {
    constructor(id, socket, server) {
        super(id, protocol_1.SessionType.SERVER);
        this[symbol_1.kSocket] = socket;
        this[symbol_1.kServer] = server;
        this[symbol_1.kState].localPort = server.localPort;
        this[symbol_1.kState].localAddress = server.localAddress;
        this[symbol_1.kState].localFamily = server.localFamily;
        this[symbol_1.kState].localAddr = new protocol_1.SocketAddress(server.address());
    }
    get server() {
        return this[symbol_1.kServer];
    }
}
exports.ServerSession = ServerSession;
//
// *************** Server ***************
//
class Server extends events_1.EventEmitter {
    constructor() {
        super();
        this[symbol_1.kSocket] = null;
        this.localFamily = '';
        this.localAddress = '';
        this.localPort = 0;
        this.listening = false;
        this.conns = new Map();
    }
    address() {
        return { port: this.localPort, family: this.localFamily, address: this.localAddress };
    }
    async listen(port, address) {
        if (this[symbol_1.kSocket])
            throw new Error('Server listening');
        let addr = await common_1.lookup(address || 'localhost');
        debug(`server listen: ${address}, ${port}`, addr);
        const socket = this[symbol_1.kSocket] = dgram_1.createSocket(addr.family === 4 ? 'udp4' : 'udp6');
        socket
            .on('error', (err) => this.emit('error', err))
            .on('close', () => serverOnClose(this))
            .on('message', (msg, rinfo) => serverOnMessage(this, socket, msg, rinfo));
        let res = new Promise((resolve, reject) => {
            socket.once('listening', () => {
                socket.removeListener('error', reject);
                let addr = socket.address();
                this.localFamily = addr.family;
                this.localAddress = addr.address;
                this.localPort = addr.port;
                this.listening = true;
                resolve();
                this.emit('listening');
            });
            socket.once('error', reject);
        });
        // Can't support cluster
        socket.bind({ port: port, address: addr.address, exclusive: true });
        return res;
    }
    close(_err) { }
    getConnections() {
        return Promise.resolve(this.conns.size);
    }
    ref() { }
    unref() { }
}
exports.Server = Server;
function serverOnMessage(server, socket, msg, rinfo) {
    debug(`server message: ${msg.length} bytes`, rinfo);
    if (!msg.length) {
        return;
    }
    // The packet size should not exceed protocol.MaxReceivePacketSize bytes
    // If it does, we only read a truncated packet, which will then end up undecryptable
    if (msg.length > protocol_1.MaxReceivePacketSize) {
        debug(`receive too large data: ${msg.length} bytes`);
        msg = msg.slice(0, protocol_1.MaxReceivePacketSize);
    }
    let senderAddr = new protocol_1.SocketAddress(rinfo);
    let rcvTime = Date.now();
    let bufv = common_1.Visitor.wrap(msg);
    let packet = null;
    try {
        packet = packet_1.parsePacket(bufv, protocol_1.SessionType.CLIENT, '');
    }
    catch (err) {
        debug(`parsing packet error: ${err.message}`);
        // drop this packet if we can't parse the Public Header
        return;
    }
    let connectionID = packet.connectionID.valueOf();
    let session = server.conns.get(connectionID);
    let newSession = !session;
    if (!session) {
        session = new ServerSession(packet.connectionID, socket, server);
        server.conns.set(connectionID, session);
    }
    if (packet.isReset()) {
        if (newSession) {
            server.conns.delete(connectionID);
            return;
        }
        // check if the remote address and the connection ID match
        // otherwise this might be an attacker trying to inject a PUBLIC_RESET to kill the connection
        let remoteAddr = session[symbol_1.kState].remoteAddr;
        if (remoteAddr && !remoteAddr.equals(senderAddr)) {
            debug(`Received a spoofed Public Reset. Ignoring.`);
            return;
        }
        let packetNumber = packet.packetNumber;
        session._closeRemote(new Error(`Received Public Reset, rejected packet number: ${packetNumber}.`));
        return;
    }
    // update the remote address, even if unpacking failed for any other reason than a decryption error
    session[symbol_1.kState].remotePort = senderAddr.port;
    session[symbol_1.kState].remoteAddress = senderAddr.address;
    session[symbol_1.kState].remoteFamily = senderAddr.family;
    session[symbol_1.kState].remoteAddr = senderAddr;
    if (newSession) {
        server.emit('session', session);
    }
    if (packet.isNegotiation()) {
        debug(`Received a unexpect Negotiation packet. Ignoring.`);
        return;
    }
    if (!session[symbol_1.kState].versionNegotiated) {
        let version = packet.version;
        if (version) {
            if (!protocol_1.isSupportedVersion(version)) {
                let negotiationPacket = packet_1.NegotiationPacket.fromConnectionID(session[symbol_1.kID]);
                session._sendPacket(negotiationPacket, (err) => {
                    if (err != null && session) {
                        session._closeRemote(err);
                    }
                });
                return;
            }
            session[symbol_1.kVersion] = version;
        }
        session[symbol_1.kState].versionNegotiated = true;
    }
    session[symbol_1.kState].bytesRead += msg.length;
    session._handleRegularPacket(packet, rcvTime, bufv);
}
function serverOnClose(_server) {
}
//# sourceMappingURL=server.js.map